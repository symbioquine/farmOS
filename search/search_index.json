{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"farmOS 2.x ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS"},{"location":"#farmos-2x","text":"ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"api/","text":"API farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"Introduction"},{"location":"api/#api","text":"farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"API"},{"location":"api/authentication/","text":"Authentication farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards . Client Libraries The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API. OAuth2 Bearer Tokens Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header. OAuth2 Details The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server. Scopes OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server. Clients An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client. Authorization Flows The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application. Authorization Code Grant The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Password Credentials Grant NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Refreshing Tokens The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Authentication"},{"location":"api/authentication/#authentication","text":"farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards .","title":"Authentication"},{"location":"api/authentication/#client-libraries","text":"The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API.","title":"Client Libraries"},{"location":"api/authentication/#oauth2-bearer-tokens","text":"Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header.","title":"OAuth2 Bearer Tokens"},{"location":"api/authentication/#oauth2-details","text":"The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server.","title":"OAuth2 Details"},{"location":"api/authentication/#scopes","text":"OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server.","title":"Scopes"},{"location":"api/authentication/#clients","text":"An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client.","title":"Clients"},{"location":"api/authentication/#authorization-flows","text":"The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application.","title":"Authorization Flows"},{"location":"api/authentication/#authorization-code-grant","text":"The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Authorization Code Grant"},{"location":"api/authentication/#password-credentials-grant","text":"NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Password Credentials Grant"},{"location":"api/authentication/#refreshing-tokens","text":"The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Refreshing Tokens"},{"location":"api/changes/","text":"API Changes 2.x vs 1.x farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api . JSON Schema farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema. Farm info endpoint In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language Resource endpoints In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity IDs farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x. Record structure JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } } Filtering The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete Text format Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default . Logs Log types The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test Log fields Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab See also \"Text format\" above for information about the changes to the format parameter of long text fields. Log status In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future. Assets Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset . Asset types Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged) Asset fields Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): archived -> status and archived (see \"Asset status\" below) date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image animal_castrated -> castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag Asset status In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active.","title":"Changes"},{"location":"api/changes/#api-changes","text":"","title":"API Changes"},{"location":"api/changes/#2x-vs-1x","text":"farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api .","title":"2.x vs 1.x"},{"location":"api/changes/#json-schema","text":"farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema.","title":"JSON Schema"},{"location":"api/changes/#farm-info-endpoint","text":"In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language","title":"Farm info endpoint"},{"location":"api/changes/#resource-endpoints","text":"In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity","title":"Resource endpoints"},{"location":"api/changes/#ids","text":"farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x.","title":"IDs"},{"location":"api/changes/#record-structure","text":"JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } }","title":"Record structure"},{"location":"api/changes/#filtering","text":"The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete","title":"Filtering"},{"location":"api/changes/#text-format","text":"Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default .","title":"Text format"},{"location":"api/changes/#logs","text":"","title":"Logs"},{"location":"api/changes/#log-types","text":"The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test","title":"Log types"},{"location":"api/changes/#log-fields","text":"Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab See also \"Text format\" above for information about the changes to the format parameter of long text fields.","title":"Log fields"},{"location":"api/changes/#log-status","text":"In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Log status"},{"location":"api/changes/#assets","text":"Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset .","title":"Assets"},{"location":"api/changes/#asset-types","text":"Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged)","title":"Asset types"},{"location":"api/changes/#asset-fields","text":"Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): archived -> status and archived (see \"Asset status\" below) date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image animal_castrated -> castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag","title":"Asset fields"},{"location":"api/changes/#asset-status","text":"In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active.","title":"Asset status"},{"location":"development/environment/","text":"Getting started Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose . 1. Set up Docker containers Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml sudo docker-compose up -d 2. Install farmOS Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db 3. Develop Open the www directory in your favorite IDE. Optional Configure private filesystem In order to upload files, the following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = 'sites/default/private/files'; Configure debugger See Debugging .","title":"Getting started"},{"location":"development/environment/#getting-started","text":"Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose .","title":"Getting started"},{"location":"development/environment/#1-set-up-docker-containers","text":"Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml sudo docker-compose up -d","title":"1. Set up Docker containers"},{"location":"development/environment/#2-install-farmos","text":"Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db","title":"2. Install farmOS"},{"location":"development/environment/#3-develop","text":"Open the www directory in your favorite IDE.","title":"3. Develop"},{"location":"development/environment/#optional","text":"","title":"Optional"},{"location":"development/environment/#configure-private-filesystem","text":"In order to upload files, the following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = 'sites/default/private/files';","title":"Configure private filesystem"},{"location":"development/environment/#configure-debugger","text":"See Debugging .","title":"Configure debugger"},{"location":"development/environment/code/","text":"Coding standards farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: sudo docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : sudo docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/code/#coding-standards","text":"farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: sudo docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : sudo docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/composer/","text":"Composer The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management. Running Composer in Docker In order to run the composer command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: sudo docker exec -it -u www-data farmos_www_1 composer help Common tasks Some common Composer tasks are documented here. Updating dependencies composer update [package-name] Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc. Adding a module composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush . Notes Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Composer"},{"location":"development/environment/composer/#composer","text":"The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management.","title":"Composer"},{"location":"development/environment/composer/#running-composer-in-docker","text":"In order to run the composer command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: sudo docker exec -it -u www-data farmos_www_1 composer help","title":"Running Composer in Docker"},{"location":"development/environment/composer/#common-tasks","text":"Some common Composer tasks are documented here.","title":"Common tasks"},{"location":"development/environment/composer/#updating-dependencies","text":"composer update [package-name] Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc.","title":"Updating dependencies"},{"location":"development/environment/composer/#adding-a-module","text":"composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush .","title":"Adding a module"},{"location":"development/environment/composer/#notes","text":"Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Notes"},{"location":"development/environment/debug/","text":"Debugging The farmOS development Docker image comes pre-installed with XDebug . In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's remote_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: sudo docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 Restart the Docker containers for this change to take affect. sudo docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it. PHPStorm If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint. Drush + PHPStorm Debugging code that is run via Drush commands requires additional configuration. Add idekey=PHPSTORM to the XDEBUG_CONFIG environment variable, and add a PHP_IDE_CONFIG environment variable with serverName=localhost , as follows: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 idekey=PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Debugging"},{"location":"development/environment/debug/#debugging","text":"The farmOS development Docker image comes pre-installed with XDebug . In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's remote_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: sudo docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 Restart the Docker containers for this change to take affect. sudo docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/environment/debug/#phpstorm","text":"If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint.","title":"PHPStorm"},{"location":"development/environment/debug/#drush-phpstorm","text":"Debugging code that is run via Drush commands requires additional configuration. Add idekey=PHPSTORM to the XDEBUG_CONFIG environment variable, and add a PHP_IDE_CONFIG environment variable with serverName=localhost , as follows: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 idekey=PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Drush + PHPStorm"},{"location":"development/environment/docker/","text":"Docker Docker build arguments The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker"},{"location":"development/environment/docker/#docker","text":"","title":"Docker"},{"location":"development/environment/docker/#docker-build-arguments","text":"The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker build arguments"},{"location":"development/environment/documentation/","text":"Documentation In addition to the code for farmOS 2.x, this repository includes the source files of the documentation which is hosted at http://2x.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-bootstrap mkdocs-bootswatch $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/documentation/#documentation","text":"In addition to the code for farmOS 2.x, this repository includes the source files of the documentation which is hosted at http://2x.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-bootstrap mkdocs-bootswatch $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/drush/","text":"Drush The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation. Running Drush in Docker In order to run the drush command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: sudo docker exec -it -u www-data farmos_www_1 drush cr Useful commands Some useful Drush commands are documented here. Rebuild caches drush cr Install a module drush en log","title":"Drush"},{"location":"development/environment/drush/#drush","text":"The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation.","title":"Drush"},{"location":"development/environment/drush/#running-drush-in-docker","text":"In order to run the drush command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: sudo docker exec -it -u www-data farmos_www_1 drush cr","title":"Running Drush in Docker"},{"location":"development/environment/drush/#useful-commands","text":"Some useful Drush commands are documented here.","title":"Useful commands"},{"location":"development/environment/drush/#rebuild-caches","text":"drush cr","title":"Rebuild caches"},{"location":"development/environment/drush/#install-a-module","text":"drush en log","title":"Install a module"},{"location":"development/environment/postgresql/","text":"PostgreSQL The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line. Open PostgreSQL prompt sudo docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#postgresql","text":"The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#open-postgresql-prompt","text":"sudo docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"Open PostgreSQL prompt"},{"location":"development/environment/tests/","text":"Automated tests The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log","title":"Automated tests"},{"location":"development/environment/tests/#automated-tests","text":"The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log","title":"Automated tests"},{"location":"development/module/fields/","text":"Fields Select options Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates). Examples: Flag An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled. Lab test type The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test ID tag type ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundle: null .","title":"Fields"},{"location":"development/module/fields/#fields","text":"","title":"Fields"},{"location":"development/module/fields/#select-options","text":"Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates).","title":"Select options"},{"location":"development/module/fields/#examples","text":"","title":"Examples:"},{"location":"development/module/fields/#flag","text":"An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled.","title":"Flag"},{"location":"development/module/fields/#lab-test-type","text":"The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test","title":"Lab test type"},{"location":"development/module/fields/#id-tag-type","text":"ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundle: null .","title":"ID tag type"},{"location":"development/module/oauth/","text":"OAuth The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API . Providing OAuth Clients OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior. Scopes OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site. Client Configuration Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"OAuth"},{"location":"development/module/oauth/#oauth","text":"The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API .","title":"OAuth"},{"location":"development/module/oauth/#providing-oauth-clients","text":"OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior.","title":"Providing OAuth Clients"},{"location":"development/module/oauth/#scopes","text":"OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site.","title":"Scopes"},{"location":"development/module/oauth/#client-configuration","text":"Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"Client Configuration"},{"location":"development/module/roles/","text":"Roles Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\". Managed Roles The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles. Creating a managed role User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): # user.role.farm_manager.yml ... standard role config ... third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. # user.role.farm_harvester.yml ... standard role config ... third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all Providing permissions for managed roles Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: # farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy Permission callbacks Example that adds permissions conditionally based on the role name and settings: Plugin definition: # my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : <?php # my_module/src/CustomPermissions.php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Roles"},{"location":"development/module/roles/#roles","text":"Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\".","title":"Roles"},{"location":"development/module/roles/#managed-roles","text":"The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles.","title":"Managed Roles"},{"location":"development/module/roles/#creating-a-managed-role","text":"User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): # user.role.farm_manager.yml ... standard role config ... third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. # user.role.farm_harvester.yml ... standard role config ... third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all","title":"Creating a managed role"},{"location":"development/module/roles/#providing-permissions-for-managed-roles","text":"Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: # farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy","title":"Providing permissions for managed roles"},{"location":"development/module/roles/#permission-callbacks","text":"Example that adds permissions conditionally based on the role name and settings: Plugin definition: # my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : <?php # my_module/src/CustomPermissions.php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Permission callbacks"},{"location":"hosting/migration/","text":"Migrating from farmOS 1.x to 2.x Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see \"Uploaded files\" below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" Uploaded files farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully. Limitations The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"1.x Migration"},{"location":"hosting/migration/#migrating-from-farmos-1x-to-2x","text":"Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see \"Uploaded files\" below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\"","title":"Migrating from farmOS 1.x to 2.x"},{"location":"hosting/migration/#uploaded-files","text":"farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully.","title":"Uploaded files"},{"location":"hosting/migration/#limitations","text":"The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Limitations"}]}